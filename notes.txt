-------------Requirements-------------

- philos do not communicate with each others
- no global variables
- no data races
	- two threads accessing data at the same time and at least one thread is also modifying the data
- each philo is a thread
- one fork between each pair of philos
	- as many forks as philos
	- fork duplication should be prevented by using mutex on fork state
- every philo has a number ranging from 1 to n
- philos sit at round table, so that philo 1 sits next to philo n
- goal of program is the avoidance of death

Input
	- number of philosophers
	- time to die
		- milliseconds since last meal till philos die
	- time to eat
		- during eating two forks have to be held
	- time to sleep
		- sleep after eating
	- [number of times each philosopher must eat]
		- optional
		- number after if all philos have eaten this much, simulation stops

Output
	- timestamp_in_ms philo_n has taken a fork
	- timestamp_in_ms philo_n is eating
	- timestamp_in_ms philo_n is sleeping
	- timestamp_in_ms philo_n is thinking
	- timestamp_in_ms philo_n died
- messages shouldnt be mixed
- message announcing death should be displayed at max 10ms after the actual death

What is making the problem complicated?
	- thread management
	- fork and mutex management

Allowed Functions
	- gettimeofday
		- get systemtime
		- time since last boot
	- usleep
		- lets program sleep for param milliseconds
	- pthread_create
		- function for creating new threads with a functionpointer as an execution routine
	- pthread_detach
		- meaning not entirely clear, detached threads are used when the main does not need to wait for completion of subthread
		- what is the difference between a detached thread and a normal one before the join function is called?
	- pthread_join
		- blocks calling thread until the thread specified completes
	- pthread_mutex_init
		- used to initialize a mutex, which is an object used to protect shared resources from simultaneous thread access
	- pthread_mutex_destroy
		- destroy mutex blocked resources
	- pthread_mutex_lock
		- will lock mutex so that only the calling thread can access it
		- if already blocked by another thread, the calling thread is blocked until the mutex is free for use
	- pthread_mutex_unlock
		- unlocks the mutex again



----------------Problem Breakdown--------------

Data Management
	struct philo_info
	- philo number
	- eat time
	- sleep time
	- max number of eats
	- first fork pointer
	- second fork pointer

- Parser
	- putting some args into a struct that is passed to the thread routine function
- Thread Initializer
	- creating philo_n threads and starting the routine in each of them
	- philo parameters are passed to the routine_func
- Fork Initializer
	- creating one mutex for each philo
	- ??
- Philo Routine
	- while times_eat < total_times_to_eat
		- lock fork
			- if already locked, think
		- eat
		- unlock fork
		- sleep
	- how to track time since beginning of last meal?
- Killer
	- kills all threads if a philo dies
		- how to check for death?






----------Learnings-----------

- project structure should be more object oriented and modeled to make understanding easier
- be more focused during implementation to get better structure from the beginning 
- thread handling
- data races prevention
- lldb usage
- helgrind usage
- enum and typedef usage
- using headers to split a project in logic blocks with only certain functions available outside
- Makefile knowledge still limited
